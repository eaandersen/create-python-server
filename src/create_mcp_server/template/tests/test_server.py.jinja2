"""
Tests for the {{ server_name }} MCP server.
"""

import pytest
from unittest.mock import patch, MagicMock, AsyncMock
from mcp.types import Resource, TextContent
from pydantic import AnyUrl
from {{ server_directory }}.server import (
    handle_list_resources,
    handle_call_tool,
    handle_read_resource,
    handle_list_prompts,
    handle_get_prompt,
    notes,
    server,
)
import anyio


@pytest.fixture
def mock_server_context():
    """Mock server request context for testing"""
    from mcp.shared.context import RequestContext
    from mcp.shared.session import BaseSession
    from mcp.server.models import InitializationOptions
    from mcp.server.lowlevel.server import NotificationOptions, request_ctx
    from mcp.types import (
        ServerRequest,
        ServerNotification,
        JSONRPCMessage,
        RequestParams,
    )

    class TestSession(BaseSession):
        """Test session that mocks the required methods"""

        async def send_resource_list_changed(self):
            await self.send_notification(
                {"method": "resourceListChanged", "params": {}}
            )

        async def send_log_message(self, level: str, data: str):
            await self.send_notification(
                {"method": "logMessage", "params": {"level": level, "data": data}}
            )

        async def send_notification(self, notification):
            # Mock implementation for testing
            pass

    # Create memory streams for the session
    receive_stream, send_stream = anyio.create_memory_object_stream[
        JSONRPCMessage | Exception
    ]()
    write_receive, write_send = anyio.create_memory_object_stream[JSONRPCMessage]()

    # Create test session with required arguments
    session = TestSession(
        read_stream=receive_stream,
        write_stream=write_send,
        receive_request_type=ServerRequest,
        receive_notification_type=ServerNotification,
    )

    session.send_resource_list_changed = AsyncMock()
    session.send_log_message = AsyncMock()
    session.send_notification = AsyncMock()

    # Create request meta data
    meta = RequestParams.Meta(client_name="test-client", client_version="1.0.0")

    # Create the context with all required arguments
    context = RequestContext(request_id="test-request-1", meta=meta, session=session)

    # Set the context in the ContextVar
    token = request_ctx.set(context)
    yield context
    request_ctx.reset(token)  # Clean up after the test


@pytest.fixture(autouse=True)
def clear_notes():
    """Clear notes before each test"""
    notes.clear()
    yield
    notes.clear()


def test_server_initialization():
    """Test server initialization."""
    assert server.name == "{{ server_name }}"


@pytest.mark.asyncio
async def test_list_empty_resources():
    """Test listing resources when no notes exist."""
    resources = await handle_list_resources()
    assert isinstance(resources, list)
    assert len(resources) == 0


@pytest.mark.asyncio
async def test_add_note_and_list_resources(mock_server_context):
    """Test adding a note and then listing it as a resource."""
    try:
        result = await handle_call_tool(
            "add-note", {"name": "test-note", "content": "This is a test note"}
        )
        assert isinstance(result, list)
        assert len(result) == 1
        assert "Added note 'test-note'" in result[0].text

        # Verify the notification was sent
        mock_server_context.session.send_resource_list_changed.assert_called_once()

        resources = await handle_list_resources()
        assert len(resources) == 1
        resource = resources[0]
        assert isinstance(resource, Resource)
        assert resource.name == "Note: test-note"
    except Exception as e:
        # Log the error for debugging
        await mock_server_context.session.send_log_message(
            level="error", data=f"Test failed: {str(e)}"
        )
        raise


@pytest.mark.asyncio
async def test_read_resource(mock_server_context):
    """Test reading a note resource."""
    note_content = "This is a test note"
    await handle_call_tool("add-note", {"name": "test-note", "content": note_content})
    content = await handle_read_resource(AnyUrl("note://internal/test-note"))
    assert content == note_content


@pytest.mark.asyncio
async def test_invalid_resource_uri():
    """Test reading a resource with invalid URI."""
    with pytest.raises(ValueError) as exc_info:
        await handle_read_resource(AnyUrl("http://invalid/uri"))
    assert "Unsupported URI scheme" in str(exc_info.value)


@pytest.mark.asyncio
async def test_list_prompts():
    """Test listing available prompts."""
    prompts = await handle_list_prompts()
    assert isinstance(prompts, list)
    assert len(prompts) == 1
    prompt = prompts[0]
    assert prompt.name == "summarize-notes"
    assert len(prompt.arguments) == 1
    assert prompt.arguments[0].name == "style"


@pytest.mark.asyncio
async def test_get_prompt(mock_server_context):
    """Test getting a prompt with different styles."""
    await handle_call_tool("add-note", {"name": "note1", "content": "Content 1"})
    await handle_call_tool("add-note", {"name": "note2", "content": "Content 2"})

    result = await handle_get_prompt("summarize-notes", {"style": "brief"})
    assert isinstance(result.messages, list)
    assert len(result.messages) == 1
    assert "Content 1" in result.messages[0].content.text
    assert "Content 2" in result.messages[0].content.text


@pytest.mark.asyncio
async def test_invalid_prompt():
    """Test getting an invalid prompt."""
    with pytest.raises(ValueError) as exc_info:
        await handle_get_prompt("invalid-prompt", {})
    assert "Unknown prompt" in str(exc_info.value)
